/**
 * Slug Generation Library
 * Feature: 004-preserve-slugs
 *
 * Main entry point for deterministic slug generation.
 */

import { normalizeForSlug } from './normalize';
import { SlugResult, SlugCollisionError, GenerateSlugFn } from './types';

// Re-export types and errors
export {
  ContentSourceFile,
  SlugResult,
  SlugManifestEntry,
  SlugManifest,
  VerificationStatus,
  VerificationDetail,
  VerificationReport,
  ContentStructureError,
  SlugCollisionError,
} from './types';

// Re-export functions
export { normalizeForSlug } from './normalize';
export { enumerateContentFiles } from './enumerate';
export { loadManifest, saveManifest, updateManifest } from './manifest';
export { verifySlug, generateVerificationReport } from './verify';

/**
 * Generate a slug from a content file's relative path.
 * Path must follow {collection}/index.md pattern.
 *
 * @param relativePath - Path relative to content/blog/, e.g., "my-post/index.md"
 * @returns SlugResult with generated slug or error
 */
export const generateSlug: GenerateSlugFn = (relativePath: string): SlugResult => {
  // Normalize path separators
  const normalizedPath = relativePath.replace(/\\/g, '/');

  // Validate path structure: must be {collection}/index.md
  const pathParts = normalizedPath.split('/').filter((p) => p.length > 0);

  // Must have exactly 2 parts: collection folder and index.md
  if (pathParts.length !== 2) {
    return {
      slug: '',
      sourcePath: relativePath,
      isValid: false,
      error: `Invalid path depth: expected {collection}/index.md, got "${relativePath}"`,
    };
  }

  const [collection, filename] = pathParts;

  // Filename must be index.md
  if (filename !== 'index.md') {
    return {
      slug: '',
      sourcePath: relativePath,
      isValid: false,
      error: `Invalid filename: expected "index.md", got "${filename}"`,
    };
  }

  // Validate collection name (should already be normalized in filesystem)
  if (!collection || collection.trim().length === 0) {
    return {
      slug: '',
      sourcePath: relativePath,
      isValid: false,
      error: 'Collection name cannot be empty',
    };
  }

  // Normalize the collection name and generate slug
  const normalizedCollection = normalizeForSlug(collection);

  return {
    slug: `/${normalizedCollection}/`,
    sourcePath: relativePath,
    isValid: true,
  };
};

/**
 * Detect slug collisions in a set of slug results.
 * Throws SlugCollisionError if duplicates are found.
 *
 * @param results - Array of SlugResult objects
 * @throws SlugCollisionError if duplicate slugs detected
 */
export function detectCollisions(results: SlugResult[]): void {
  const slugMap = new Map<string, string[]>();

  for (const result of results) {
    if (!result.isValid) continue;

    const paths = slugMap.get(result.slug) || [];
    paths.push(result.sourcePath);
    slugMap.set(result.slug, paths);
  }

  for (const [slug, paths] of slugMap) {
    if (paths.length > 1) {
      throw new SlugCollisionError(
        `Slug collision detected: "${slug}" is generated by multiple paths`,
        slug,
        paths
      );
    }
  }
}
