{
  "projects": [
    {
      "slug": "remo",
      "name": "Remo",
      "status": "ready",
      "summary": "Automated provisioning of cloud development servers with DevContainer support, persistent sessions, and one-command deployment to Hetzner Cloud.",
      "details": "## Overview\n\nRemo automates the complete setup of remote development servers on Hetzner Cloud. It's designed for developers who want persistent, accessible-from-anywhere coding environments without the complexity of manual server configuration or the cost of always-on cloud IDEs. With a single command (or GitHub Actions workflow), you get a fully-configured development server with Docker, DevContainers, terminal multiplexing, and persistent storage.\n\n## Key Features\n\n- **One-Command Provisioning** - Run `./run.sh site.yml` or trigger a GitHub Actions workflow to provision a complete development server with Docker, Node.js, DevContainers CLI, and all supporting tools\n- **Persistent Storage** - 20GB Hetzner volume survives server teardown, so your data persists across rebuilds while keeping costs minimal\n- **DevContainer Workflow** - Full `devcontainer` CLI support with automatic project detection, auto-launching menus, and automatic rebuild when configuration changes\n- **Zellij Session Persistence** - Terminal multiplexer maintains your work state even after SSH disconnection—reconnect and resume exactly where you left off\n- **GitHub Actions Integration** - Fork the repo and provision servers entirely through GitHub's UI without any local setup required\n- **Cost-Optimized Architecture** - Pay-per-minute Hetzner pricing (~€4/month) with built-in teardown workflows for automatic cost control\n\n## Use Cases\n\nRemo excels in these specific scenarios:\n\n- **Remote-First Development** - Work from any machine with only an SSH client, accessing your persistent development environment\n- **Expensive Local Hardware Avoidance** - Offload heavy compilation and container builds to a cloud server\n- **Multi-Project Workflows** - Use the auto-launching project menu to switch between DevContainer-based projects\n- **Temporary High-Power Needs** - Spin up powerful servers for intensive tasks, tear down when done\n- **Team Onboarding** - New members provision identical environments via GitHub Actions without local tooling\n- **Container Development** - Build and test Docker images on dedicated servers\n\n## Technical Highlights\n\nRemo uses Ansible 2.14+ with a role-based architecture for idempotent, reproducible deployments. Key roles include `hetzner_server` (server/firewall/volume creation via hetzner.hcloud collection), `docker` (Docker CE + compose), `devcontainers` (CLI installation), and `zellij` (terminal multiplexer). The design separates provisioning from configuration, allowing partial re-runs. A nested Zellij configuration prevents keybind conflicts inside DevContainers.\n\n## Getting Started\n\nClone the repository and copy `.env.example` to `.env`, then fill in your Hetzner API token, DuckDNS credentials, and SSH public key. Run `./run.sh site.yml` to provision and configure a complete server. Alternatively, fork the repo, add credentials as GitHub secrets, and use the \"Provision Server\" workflow in GitHub Actions.",
      "tags": ["ansible", "devcontainers", "cloud-development", "hetzner", "remote-dev", "infrastructure-as-code"],
      "links": [
        {
          "label": "GitHub",
          "url": "https://github.com/get2knowio/remo",
          "type": "primary"
        }
      ]
    },
    {
      "slug": "maverick",
      "name": "Maverick",
      "status": "in-progress",
      "summary": "AI-powered development workflow orchestration that uses autonomous Claude agents to implement features, fix issues, run code reviews, and create PRs from declarative YAML definitions.",
      "details": "## Overview\n\nMaverick is a Python CLI/TUI application that orchestrates complete development workflows using the Claude Agent SDK. It automates the full development lifecycle—from implementing features defined in task lists, through code review and validation, to PR creation—using autonomous AI agents that make decisions and recover from failures. Unlike traditional CI/CD tools that run static scripts, Maverick's agents dynamically adapt to errors, retry with fixes, and handle complex multi-phase implementations.\n\n## Key Features\n\n- **Declarative YAML Workflows** - Define multi-step workflows with conditional execution, parallel steps, checkpoints, and sub-workflow composition. The DSL supports expression evaluation, iteration, and type-safe inputs.\n- **Autonomous AI Agents** - Specialized agents (ImplementerAgent, CodeReviewerAgent, FixerAgent) execute tasks using Claude, with built-in tool permission scoping and structured result extraction.\n- **Validation-Fix Loops** - Automatic retry cycles run format/lint/typecheck/test stages, then invoke a fixer agent to resolve failures before retrying.\n- **Interactive TUI** - Real-time Textual-based interface shows agent operations, validation progress, review findings, and workflow state.\n- **Workflow Discovery & Customization** - Three-tier discovery (project → user → built-in) lets teams override any workflow by placing modified YAML in `.maverick/workflows/`.\n- **Checkpointing & Resumption** - Workflows can checkpoint state to disk, enabling resumption from any checkpoint if interrupted.\n\n## Use Cases\n\nMaverick excels at automating development workflows that would otherwise require manual coordination:\n\n- Implementing features from spec files with automatic validation and PR creation\n- Batch processing tech-debt issues with parallel fixes and individual PRs\n- Single-issue quick fixes with automatic commit and push\n- AI-powered code review for architecture and convention compliance\n- Validation pipelines with automatic fix attempts on failure\n- Custom team workflows composed from reusable fragments\n\n## Technical Highlights\n\nBuilt on the Claude Agent SDK with a clean layered architecture: CLI (Click) → Workflow DSL (YAML parsing, step execution, checkpointing) → Agent layer (system prompts, tool selection) → Tool layer (MCP servers for GitHub/Git). The YAML DSL supports eight step types including python, agent, validate, parallel, subworkflow, branch, and checkpoint. All agents receive explicit allowed_tools following least-privilege principles, and all workflows are fully async with structured logging via structlog.\n\n## Getting Started\n\nInstall with `uv sync` after cloning the repository, then set your `ANTHROPIC_API_KEY`. Run `maverick workflow list` to see available workflows, or execute with `maverick fly feature -i branch_name=my-feature`. Customize by copying any built-in workflow YAML to `.maverick/workflows/` and modifying it.",
      "tags": ["python", "claude-ai", "workflow-automation", "cli", "tui", "developer-tools"],
      "links": [
        {
          "label": "GitHub",
          "url": "https://github.com/get2knowio/maverick",
          "type": "primary"
        },
        {
          "label": "Documentation",
          "url": "https://get2knowio.github.io/maverick/"
        },
        {
          "label": "Training Slides",
          "url": "https://get2knowio.github.io/maverick/slides/"
        }
      ]
    },
    {
      "slug": "deacon",
      "name": "Deacon",
      "status": "in-progress",
      "summary": "A fast, lightweight Rust implementation of the DevContainer CLI for reproducible development environments.",
      "details": "## Overview\n\nDeacon is a production-ready Rust implementation of the Development Containers CLI, following the containers.dev specification. It provides DevOps teams and developers with a fast, cross-platform tool for managing containerized development environments without requiring Node.js. With a startup time under 100ms and a ~40MB binary, Deacon brings the full power of DevContainers to CI/CD pipelines and teams seeking lightweight, reproducible workflows.\n\n## Key Features\n\n- **Container Lifecycle Management** - Full `up`/`exec`/`down` commands with all lifecycle phases (onCreate, postCreate, postStart, postAttach), idempotent operations, and container state persistence.\n- **Configuration Resolution** - Complete `devcontainer.json` parsing with variable substitution, extends chains for layered configurations, and Docker Compose multi-service orchestration.\n- **OCI Feature System** - Install, test, package, and publish reusable features via OCI registries with dependency resolution, parallel installation, and lockfile support for reproducible builds.\n- **Template Management** - Create and publish parameterized project templates with scaffolding options, metadata generation, and registry publication for team sharing.\n- **Container Image Building** - Dockerfile-based builds from devcontainer configs with BuildKit integration for secrets, SSH forwarding, caching, and multi-architecture support.\n- **System Diagnostics** - Built-in `doctor` command validates Docker availability, disk space, CPU, and memory requirements with JSON output for automation.\n\n## Use Cases\n\nDeacon excels in these scenarios:\n\n- Standardizing team development environments with version-controlled configurations\n- CI/CD pipeline integration with fast startup and JSON output modes\n- Open-source project onboarding with single-command setup\n- Feature development, testing, and publishing to OCI registries\n- Multi-platform container builds with BuildKit integration\n- Migrating from VS Code Dev Containers to CLI-first workflows\n\n## Technical Highlights\n\nBuilt in Rust (Edition 2021) using tokio for async I/O, reqwest with rustls for OCI registry operations, and clap for CLI parsing. The architecture separates the CLI binary from the core domain library, with abstractions like `ContainerRuntime` (Docker/Podman), `ConfigLoader` (extends chain resolution), and `FeatureInstaller` (OCI installation with dependency resolution). Performance optimizations include container environment probe caching and parallel feature installation.\n\n## Getting Started\n\nInstall via curl: `curl -fsSL https://get2knowio.github.io/deacon/install.sh | bash`. Run `deacon up --workspace-folder .` in any directory with a `.devcontainer/devcontainer.json` to start a development container. Use `deacon exec -- <command>` to run commands inside, and `deacon doctor --json` for system diagnostics.",
      "tags": ["rust", "devcontainers", "docker", "cli", "developer-tools", "oci"],
      "links": [
        {
          "label": "GitHub",
          "url": "https://github.com/get2knowio/deacon",
          "type": "primary"
        },
        {
          "label": "Documentation",
          "url": "https://github.com/get2knowio/deacon/tree/main/docs"
        },
        {
          "label": "containers.dev Spec",
          "url": "https://containers.dev"
        }
      ]
    },
    {
      "slug": "newcleus",
      "name": "Newcleus",
      "status": "coming-soon",
      "summary": "It's a wiki wiki wiki wiki...",
      "details": "## Coming Soon",
      "tags": ["nodejs", "typescript"],
      "links": [
        {
          "label": "GitHub",
          "url": "https://github.com/pfallon-ofallon/newcleus",
          "type": "primary"
        }
      ]
    }
  ]
}
