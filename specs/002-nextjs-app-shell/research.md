# Research Log — Next.js Site Shell

## Testing strategy (NEEDS CLARIFICATION)
- **Decision**: Use `next/jest` with React Testing Library for unit/integration tests plus Playwright for end-to-end navigation checks.
- **Rationale**: `next/jest` bootstraps Jest with the Next.js compiler, keeping type-aware transforms aligned with the App Router, while Testing Library emphasizes behavior-focused assertions; Playwright already supports Next dev servers and gives us deterministic multi-browser verification for the navigation shell required by User Story 1.
- **Alternatives considered**: Vitest (lighter but would require manual SWC configuration for Next App Router); Cypress (great DX but higher resource footprint and less aligned with GitHub workflows already using Playwright).

## Next.js 14 App Router best practices
- **Decision**: Organize all routes under `/app`, use `layout.tsx` for the global shell, and define static metadata via the exported `metadata` object plus shared navigation data in `/lib`.
- **Rationale**: App Router layouts persist across route changes, minimizing re-renders for the header/footer, while colocated metadata ensures SC-002 and FR-007 are met without duplicating config.
- **Alternatives considered**: Pages Router (deprecated for new apps and would complicate nested layouts); duplicating layout components per route (violates DRY and risks shell drift).

## React 18 usage
- **Decision**: Favor server components for static placeholder routes and keep interactive pieces (e.g., responsive nav) as client components annotated with `"use client"`.
- **Rationale**: Server components reduce bundle size and align with placeholder content that is static today, while client components can remain minimal until interactive requirements arrive.
- **Alternatives considered**: All-client components (simpler initially but bloats bundle and ignores React 18 guidance); Suspense-heavy patterns (unnecessary without data fetching).

## Tailwind CSS 3.x
- **Decision**: Configure Tailwind via `tailwind.config.ts` with the App Router `content` glob (`./app/**/*.{ts,tsx}` and `./components/**/*.{ts,tsx}`) and import `globals.css` from `app/layout.tsx`.
- **Rationale**: Ensures tree-shaking covers all shell components, and central `globals.css` keeps reset/utilities loaded once per the Tailwind + Next starter recommendations.
- **Alternatives considered**: CSS Modules per component (adds boilerplate and scatters design tokens); Styled Components (requires extra Babel config and conflicts with Tailwind utility-first goals).

## PostCSS pipeline
- **Decision**: Use the standard Tailwind/PostCSS duo (`tailwindcss`, `autoprefixer`) with the config generated by `next@latest --tailwind` to stay aligned with upstream defaults.
- **Rationale**: Keeps build tooling minimal while satisfying FR-002; autoprefixer handles Progressive Enhancement requirements without manual CSS vendor handling.
- **Alternatives considered**: Custom PostCSS plugins (premature for a shell); Sass (unneeded while Tailwind covers styling needs).

## ESLint configuration
- **Decision**: Extend `next/core-web-vitals` plus `@typescript-eslint/recommended` and enable lint scripts in package.json.
- **Rationale**: Next's config already checks for a11y/perf issues tied to the App Router, and layering TS ESLint ensures strict typing rules mandated by Principle II.
- **Alternatives considered**: Default ESLint config (misses Next-specific warnings); disabling lint entirely (violates constitution principle II).

## Prettier formatting
- **Decision**: Keep Prettier with `prettier-plugin-tailwindcss` to auto-sort class utilities and enforce consistent formatting for collaborative work.
- **Rationale**: Aligns with Tailwind guidance and minimizes manual class ordering churn during migration.
- **Alternatives considered**: Rely on ESLint formatting (less opinionated about class order); skip formatting tooling (invites style drift).

## AWS Amplify deployment integration
- **Decision**: Target Amplify Hosting using the Next.js SSR preset (`amplify-hosting:deploy --app <id> --branch 002-nextjs-app-shell`) and ensure build command is `npm install && npm run build`.
- **Rationale**: Amplify supports Next 13/14 with automatic image optimization and lambda rendering; configuring now avoids later blockers when the shell graduates to production traffic.
- **Alternatives considered**: Vercel (excellent DX but conflicts with Principle V requiring Amplify); manual AWS CDK setup (overkill for initial scaffold).

## Amplify deployment notes (Phase 5 follow-up)
- **Build command**: `npm ci && npm run build --workspace apps/site-shell`
- **Start command**: `npm run start --workspace apps/site-shell`
- **Env vars**: set `NEXT_PUBLIC_SITE_URL` to the Amplify branch URL so `metadataBase` generates correct absolute URLs.
- **Artifacts**: Deploy the `.next/` directory generated inside `apps/site-shell`; Amplify automatically maps it to the SSR handler when using the Next preset.
- **Verification**: After each deploy, run `npm run test:e2e --workspace apps/site-shell -- --headed --project=chromium` locally to confirm shell navigation still matches expectations.

## Monitoring TODOs
- [ ] Wire Amplify’s CloudWatch metrics to alert on Lambda 5xx spikes for the Next.js SSR function.
- [ ] Schedule the Playwright navigation suite via GitHub Actions on a daily cron and push failures to Slack.
- [ ] Add uptime checks for `/` and `/blog` via Amazon Route 53 health checks once the Amplify branch is public.
